<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->
# Generators

## Random Graphs
*LightGraphs.jl* implements some common random graph generators:
### erdos_renyi
```julia
erdos_renyi(n::Integer, p::Real; is_directed=false, seed=-1)
erdos_renyi(n::Integer, ne::Integer; is_directed=false, seed=-1)
```

Creates an [Erdős–Rényi](http://en.wikipedia.org/wiki/Erdős–Rényi_model) random graph with `n` vertices. Edges are added between pairs of vertices with probability `p`. Undirected graphs are created by default; use `is_directed=true` to override.

Note also that Erdős–Rényi graphs may be generated quickly using `erdos_renyi(n, ne)` or the  `Graph(nv, ne)` constructor, which randomly select `ne` edges among all the potential edges.

### watts_strogatz
```julia
watts_strogatz(n::Integer, k::Integer, β::Real)
```
Creates a [Watts-Strogatz](https://en.wikipedia.org/wiki/Watts_and_Strogatz_model) small model random graph with `n` vertices, each with degree `k`. Edges are randomized per the model based on probability `β`. Undirected graphs are created by default; use `is_directed=true` to override.

### random_regular_graph
```julia
random_regular_graph(n::Int, k::Int; seed=-1)
```

Creates a random undirected [regular graph](https://en.wikipedia.org/wiki/Regular_graph) with `n` vertices, each with degree `k`.

For undirected graphs, allocates an array of `nk` `Int`s, and takes approximately $nk^2$ time. For $k > n/2$, generates a graph of degree `n-k-1` and returns its complement.

### random_regular_digraph
```julia
random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)
```

Creates a random directed [regular graph](https://en.wikipedia.org/wiki/Regular_graph) with `n` vertices, each with degree `k`. The degree (in or out) can be specified using `dir=:in` or `dir=:out`. The default is `dir=:out`.

For directed graphs, allocates an $n \times n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.

### random_configuration_model
```julia
random_configuration_model(n::Int, k::Array{Int}; seed=-1, check_graphical=false)
```

Creates a random undirected graph according to the [configuraton model](http://tuvalu.santafe.edu/~aaronc/courses/5352/fall2013/csci5352_2013_L11.pdf). It contains `n` vertices, the vertex `i` having degree `k[i]`.

Defining `c = mean(k)`, it allocates an array of `nc` `Int`s, and takes approximately $nc^2$ time.

If `check_graphical=true` makes sure that `k` is a graphical sequence (see `isgraphical`).

### barabasi_albert
```julia
barabasi_albert(n::Integer, n0::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)
```

Creates a [Barabási–Albert model](https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model) random graph with `n` vertices. It is grown by adding new vertices to an initial graph with `n0` vertices. Each new vertex is attached with `k` edges to `k` different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use `is_directed=true` and `complete=true` for directed and complete initial graphs.

```julia
barabasi_albert(n::Integer, k::Integer; is_directed::Bool = false, complete::Bool = false, seed::Int = -1)
```

Creates a [Barabási–Albert model](https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model) random graph with `n` vertices. It is grown by adding new vertices to an initial graph with `k` vertices. Each new vertex is attached with `k` edges to `k` different vertices already present in the system by preferential attachment. Initial graphs are undirected and consist of isolated vertices by default; use `is_directed=true` and `complete=true` for directed and complete initial graphs.

### stochastic_block_model
```julia
stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)
stochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)
```

Returns a Graph generated according to the Stochastic Block Model (SBM).

`c[a,b]` : Mean number of neighbors of a vertex in block `a` belonging to block `b`.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$. `n[a]` : Number of vertices in block `a`

The second form samples from a SBM with `c[a,a]=cin`, and `c[a,b]=coff`.

For a dynamic version of the SBM see the `StochasticBlockModel` type and related functions.

### StochasticBlockModel
```
type StochasticBlockModel{T<:Integer,P<:Real}
    n::T
    nodemap::Array{T}
    affinities::Matrix{P}
    rng::MersenneTwister
end
```

A type capturing the parameters of the SBM. Each vertex is assigned to a block and the probability of edge `(i,j)` depends only on the block labels of vertex `i` and vertex `j`.

The assignement is stored in nodemap and the block affinities a `k` by `k` matrix is stored in affinities.

`affinities[k,l]` is the probability of an edge between any vertex in block k and any vertex in block `l`.

We are generating the graphs by taking random `i,j in vertices(g)` and flipping a coin with probability `affinities[nodemap[i],nodemap[j]]`.

### make_edgestream
```julia
make_edgestream(sbm::StochasticBlockModel)
```

Take an infinite sample from the sbm. Pass to `Graph(nvg, neg, edgestream)` to get a Graph object.

## Static Graphs
*LightGraphs.jl* also implements a collection of classic graph generators:
### CompleteGraph
```julia
CompleteGraph(n::Integer)
```
Creates a complete graph with `n` vertices. A complete graph has edges connecting each pair of vertices.

### CompleteBipartiteGraph
```julia
CompleteBipartiteGraph(n1::Integer, n2::Integer)
```
Creates a complete bipartite graph with `n1+n2` vertices. It has edges connecting each pair of vertices in the two sets.

### CompleteDiGraph
```julia
CompleteDiGraph(n::Integer)
```
Creates a complete digraph with `n` vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).

### StarGraph
```julia
StarGraph(n::Integer)
```
Creates a star graph with `n` vertices. A star graph has a central vertex with edges to each other vertex.

### StarDiGraph
```julia
StarDiGraph(n::Integer)
```
Creates a star digraph with `n` vertices. A star digraph has a central vertex with directed edges to every other vertex.

### PathGraph
```julia
PathGraph(n::Integer)
```
Creates a path graph with `n` vertices. A path graph connects each successive vertex by a single edge.

### PathDiGraph
```julia
PathDiGraph(n::Integer)
```
Creates a path digraph with `n` vertices. A path graph connects each successive vertex by a single directed edge.

### WheelGraph
```julia
WheelGraph(n::Integer)
```
Creates a wheel graph with `n` vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.

### WheelDiGraph
```julia
WheelDiGraph(n::Integer)
```
Creates a wheel digraph with `n` vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.

### BinaryTree
```julia
BinaryTree(levels::Int64)
```
create a binary tree with k-levels vertices are numbered 1:2^levels-1

### DoubleBinaryTree
```julia
DoubleBinaryTree(levels::Int64)
```
create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.

### RoachGraph
```julia
RoachGraph(k::Int64)
```
The Roach Graph from Guattery and Miller 1998

### Grid
```julia
Grid{T<:Integer}(dims::AbstractVector{T}; periodic=false)
```

Creates a `d`-dimensional cubic lattice, with `d=length(dims)` and length  `dims[i]` in dimension `i`.  If `periodic=true` the resulting lattice will have periodic boundary condition in each dimension.   

## Smallgraphs
Many notorious graphs are available in the Datasets submodule in LightGraphsExtras.jl
```julia
using LightGraphsExtras.Datasets
```

